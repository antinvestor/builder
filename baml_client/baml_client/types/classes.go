// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type AcceptanceCriterion struct {
	Criterion           string `json:"criterion"`
	Testable            bool   `json:"testable"`
	Verification_method string `json:"verification_method"`
}

func (c *AcceptanceCriterion) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "AcceptanceCriterion" {
		panic(fmt.Sprintf("expected AcceptanceCriterion, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "criterion":
			c.Criterion = baml.Decode(valueHolder).Interface().(string)

		case "testable":
			c.Testable = baml.Decode(valueHolder).Bool()

		case "verification_method":
			c.Verification_method = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class AcceptanceCriterion", key))

		}
	}

}

func (c AcceptanceCriterion) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["criterion"] = c.Criterion

	fields["testable"] = c.Testable

	fields["verification_method"] = c.Verification_method

	return baml.EncodeClass("AcceptanceCriterion", fields, nil)
}

func (c AcceptanceCriterion) BamlTypeName() string {
	return "AcceptanceCriterion"
}

type Alternative struct {
	Approach     string `json:"approach"`
	Pros         string `json:"pros"`
	Cons         string `json:"cons"`
	Why_rejected string `json:"why_rejected"`
}

func (c *Alternative) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Alternative" {
		panic(fmt.Sprintf("expected Alternative, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "approach":
			c.Approach = baml.Decode(valueHolder).Interface().(string)

		case "pros":
			c.Pros = baml.Decode(valueHolder).Interface().(string)

		case "cons":
			c.Cons = baml.Decode(valueHolder).Interface().(string)

		case "why_rejected":
			c.Why_rejected = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class Alternative", key))

		}
	}

}

func (c Alternative) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["approach"] = c.Approach

	fields["pros"] = c.Pros

	fields["cons"] = c.Cons

	fields["why_rejected"] = c.Why_rejected

	return baml.EncodeClass("Alternative", fields, nil)
}

func (c Alternative) BamlTypeName() string {
	return "Alternative"
}

type BehaviorChange struct {
	Component        string     `json:"component"`
	Current_behavior string     `json:"current_behavior"`
	Desired_behavior string     `json:"desired_behavior"`
	Change_type      ChangeType `json:"change_type"`
}

func (c *BehaviorChange) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "BehaviorChange" {
		panic(fmt.Sprintf("expected BehaviorChange, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "component":
			c.Component = baml.Decode(valueHolder).Interface().(string)

		case "current_behavior":
			c.Current_behavior = baml.Decode(valueHolder).Interface().(string)

		case "desired_behavior":
			c.Desired_behavior = baml.Decode(valueHolder).Interface().(string)

		case "change_type":
			c.Change_type = baml.Decode(valueHolder).Interface().(ChangeType)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class BehaviorChange", key))

		}
	}

}

func (c BehaviorChange) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["component"] = c.Component

	fields["current_behavior"] = c.Current_behavior

	fields["desired_behavior"] = c.Desired_behavior

	fields["change_type"] = c.Change_type

	return baml.EncodeClass("BehaviorChange", fields, nil)
}

func (c BehaviorChange) BamlTypeName() string {
	return "BehaviorChange"
}

type CodeConstraints struct {
	Max_file_size_lines    int64     `json:"max_file_size_lines"`
	Preserve_formatting    bool      `json:"preserve_formatting"`
	Maintain_compatibility bool      `json:"maintain_compatibility"`
	Allowed_imports        *[]string `json:"allowed_imports"`
	Forbidden_patterns     *[]string `json:"forbidden_patterns"`
}

func (c *CodeConstraints) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CodeConstraints" {
		panic(fmt.Sprintf("expected CodeConstraints, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "max_file_size_lines":
			c.Max_file_size_lines = baml.Decode(valueHolder).Int()

		case "preserve_formatting":
			c.Preserve_formatting = baml.Decode(valueHolder).Bool()

		case "maintain_compatibility":
			c.Maintain_compatibility = baml.Decode(valueHolder).Bool()

		case "allowed_imports":
			c.Allowed_imports = baml.Decode(valueHolder).Interface().(*[]string)

		case "forbidden_patterns":
			c.Forbidden_patterns = baml.Decode(valueHolder).Interface().(*[]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CodeConstraints", key))

		}
	}

}

func (c CodeConstraints) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["max_file_size_lines"] = c.Max_file_size_lines

	fields["preserve_formatting"] = c.Preserve_formatting

	fields["maintain_compatibility"] = c.Maintain_compatibility

	fields["allowed_imports"] = c.Allowed_imports

	fields["forbidden_patterns"] = c.Forbidden_patterns

	return baml.EncodeClass("CodeConstraints", fields, nil)
}

func (c CodeConstraints) BamlTypeName() string {
	return "CodeConstraints"
}

type CodeContext struct {
	File_contents     map[string]string `json:"file_contents"`
	Project_structure string            `json:"project_structure"`
	Language          string            `json:"language"`
	Framework         *string           `json:"framework"`
	Style_guide       *string           `json:"style_guide"`
}

func (c *CodeContext) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CodeContext" {
		panic(fmt.Sprintf("expected CodeContext, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_contents":
			c.File_contents = baml.Decode(valueHolder).Interface().(map[string]string)

		case "project_structure":
			c.Project_structure = baml.Decode(valueHolder).Interface().(string)

		case "language":
			c.Language = baml.Decode(valueHolder).Interface().(string)

		case "framework":
			c.Framework = baml.Decode(valueHolder).Interface().(*string)

		case "style_guide":
			c.Style_guide = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CodeContext", key))

		}
	}

}

func (c CodeContext) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_contents"] = c.File_contents

	fields["project_structure"] = c.Project_structure

	fields["language"] = c.Language

	fields["framework"] = c.Framework

	fields["style_guide"] = c.Style_guide

	return baml.EncodeClass("CodeContext", fields, nil)
}

func (c CodeContext) BamlTypeName() string {
	return "CodeContext"
}

type CodeGenerationRequest struct {
	Step        PlanStep        `json:"step"`
	Context     CodeContext     `json:"context"`
	Constraints CodeConstraints `json:"constraints"`
}

func (c *CodeGenerationRequest) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CodeGenerationRequest" {
		panic(fmt.Sprintf("expected CodeGenerationRequest, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "step":
			c.Step = baml.Decode(valueHolder).Interface().(PlanStep)

		case "context":
			c.Context = baml.Decode(valueHolder).Interface().(CodeContext)

		case "constraints":
			c.Constraints = baml.Decode(valueHolder).Interface().(CodeConstraints)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CodeGenerationRequest", key))

		}
	}

}

func (c CodeGenerationRequest) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["step"] = c.Step

	fields["context"] = c.Context

	fields["constraints"] = c.Constraints

	return baml.EncodeClass("CodeGenerationRequest", fields, nil)
}

func (c CodeGenerationRequest) BamlTypeName() string {
	return "CodeGenerationRequest"
}

type CodeGenerationResult struct {
	File_changes   []FileChange `json:"file_changes"`
	Commit_message string       `json:"commit_message"`
	Notes          *string      `json:"notes"`
}

func (c *CodeGenerationResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CodeGenerationResult" {
		panic(fmt.Sprintf("expected CodeGenerationResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_changes":
			c.File_changes = baml.Decode(valueHolder).Interface().([]FileChange)

		case "commit_message":
			c.Commit_message = baml.Decode(valueHolder).Interface().(string)

		case "notes":
			c.Notes = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CodeGenerationResult", key))

		}
	}

}

func (c CodeGenerationResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_changes"] = c.File_changes

	fields["commit_message"] = c.Commit_message

	fields["notes"] = c.Notes

	return baml.EncodeClass("CodeGenerationResult", fields, nil)
}

func (c CodeGenerationResult) BamlTypeName() string {
	return "CodeGenerationResult"
}

type CodeQualityMetrics struct {
	Cyclomatic_complexity float64 `json:"cyclomatic_complexity"`
	Cognitive_complexity  float64 `json:"cognitive_complexity"`
	Lines_of_code         int64   `json:"lines_of_code"`
	Lines_of_comments     int64   `json:"lines_of_comments"`
	Comment_ratio         float64 `json:"comment_ratio"`
	Duplication_percent   float64 `json:"duplication_percent"`
}

func (c *CodeQualityMetrics) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CodeQualityMetrics" {
		panic(fmt.Sprintf("expected CodeQualityMetrics, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "cyclomatic_complexity":
			c.Cyclomatic_complexity = baml.Decode(valueHolder).Float()

		case "cognitive_complexity":
			c.Cognitive_complexity = baml.Decode(valueHolder).Float()

		case "lines_of_code":
			c.Lines_of_code = baml.Decode(valueHolder).Int()

		case "lines_of_comments":
			c.Lines_of_comments = baml.Decode(valueHolder).Int()

		case "comment_ratio":
			c.Comment_ratio = baml.Decode(valueHolder).Float()

		case "duplication_percent":
			c.Duplication_percent = baml.Decode(valueHolder).Float()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CodeQualityMetrics", key))

		}
	}

}

func (c CodeQualityMetrics) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["cyclomatic_complexity"] = c.Cyclomatic_complexity

	fields["cognitive_complexity"] = c.Cognitive_complexity

	fields["lines_of_code"] = c.Lines_of_code

	fields["lines_of_comments"] = c.Lines_of_comments

	fields["comment_ratio"] = c.Comment_ratio

	fields["duplication_percent"] = c.Duplication_percent

	return baml.EncodeClass("CodeQualityMetrics", fields, nil)
}

func (c CodeQualityMetrics) BamlTypeName() string {
	return "CodeQualityMetrics"
}

type CommitMessage struct {
	Subject string     `json:"subject"`
	Body    *string    `json:"body"`
	Type    CommitType `json:"type"`
}

func (c *CommitMessage) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CommitMessage" {
		panic(fmt.Sprintf("expected CommitMessage, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "subject":
			c.Subject = baml.Decode(valueHolder).Interface().(string)

		case "body":
			c.Body = baml.Decode(valueHolder).Interface().(*string)

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(CommitType)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CommitMessage", key))

		}
	}

}

func (c CommitMessage) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["subject"] = c.Subject

	fields["body"] = c.Body

	fields["type"] = c.Type

	return baml.EncodeClass("CommitMessage", fields, nil)
}

func (c CommitMessage) BamlTypeName() string {
	return "CommitMessage"
}

type CommitMessageRequest struct {
	File_changes     []FileChange `json:"file_changes"`
	Feature_context  string       `json:"feature_context"`
	Step_description string       `json:"step_description"`
}

func (c *CommitMessageRequest) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CommitMessageRequest" {
		panic(fmt.Sprintf("expected CommitMessageRequest, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_changes":
			c.File_changes = baml.Decode(valueHolder).Interface().([]FileChange)

		case "feature_context":
			c.Feature_context = baml.Decode(valueHolder).Interface().(string)

		case "step_description":
			c.Step_description = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CommitMessageRequest", key))

		}
	}

}

func (c CommitMessageRequest) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_changes"] = c.File_changes

	fields["feature_context"] = c.Feature_context

	fields["step_description"] = c.Step_description

	return baml.EncodeClass("CommitMessageRequest", fields, nil)
}

func (c CommitMessageRequest) BamlTypeName() string {
	return "CommitMessageRequest"
}

type ComplexityAssessment struct {
	Level           ComplexityLevel `json:"level"`
	Estimated_steps int64           `json:"estimated_steps"`
	Estimated_files int64           `json:"estimated_files"`
	Rationale       string          `json:"rationale"`
}

func (c *ComplexityAssessment) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComplexityAssessment" {
		panic(fmt.Sprintf("expected ComplexityAssessment, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "level":
			c.Level = baml.Decode(valueHolder).Interface().(ComplexityLevel)

		case "estimated_steps":
			c.Estimated_steps = baml.Decode(valueHolder).Int()

		case "estimated_files":
			c.Estimated_files = baml.Decode(valueHolder).Int()

		case "rationale":
			c.Rationale = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ComplexityAssessment", key))

		}
	}

}

func (c ComplexityAssessment) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["level"] = c.Level

	fields["estimated_steps"] = c.Estimated_steps

	fields["estimated_files"] = c.Estimated_files

	fields["rationale"] = c.Rationale

	return baml.EncodeClass("ComplexityAssessment", fields, nil)
}

func (c ComplexityAssessment) BamlTypeName() string {
	return "ComplexityAssessment"
}

type ComponentReference struct {
	Name    string        `json:"name"`
	Path    string        `json:"path"`
	Type    ComponentType `json:"type"`
	Purpose string        `json:"purpose"`
}

func (c *ComponentReference) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComponentReference" {
		panic(fmt.Sprintf("expected ComponentReference, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(string)

		case "path":
			c.Path = baml.Decode(valueHolder).Interface().(string)

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(ComponentType)

		case "purpose":
			c.Purpose = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ComponentReference", key))

		}
	}

}

func (c ComponentReference) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["name"] = c.Name

	fields["path"] = c.Path

	fields["type"] = c.Type

	fields["purpose"] = c.Purpose

	return baml.EncodeClass("ComponentReference", fields, nil)
}

func (c ComponentReference) BamlTypeName() string {
	return "ComponentReference"
}

type CoverageGap struct {
	File_path string `json:"file_path"`
	Symbol    string `json:"symbol"`
	Reason    string `json:"reason"`
}

func (c *CoverageGap) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CoverageGap" {
		panic(fmt.Sprintf("expected CoverageGap, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(string)

		case "symbol":
			c.Symbol = baml.Decode(valueHolder).Interface().(string)

		case "reason":
			c.Reason = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class CoverageGap", key))

		}
	}

}

func (c CoverageGap) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_path"] = c.File_path

	fields["symbol"] = c.Symbol

	fields["reason"] = c.Reason

	return baml.EncodeClass("CoverageGap", fields, nil)
}

func (c CoverageGap) BamlTypeName() string {
	return "CoverageGap"
}

type DependencyEdge struct {
	From_id   string   `json:"from_id"`
	To_id     string   `json:"to_id"`
	Edge_type EdgeType `json:"edge_type"`
}

func (c *DependencyEdge) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DependencyEdge" {
		panic(fmt.Sprintf("expected DependencyEdge, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "from_id":
			c.From_id = baml.Decode(valueHolder).Interface().(string)

		case "to_id":
			c.To_id = baml.Decode(valueHolder).Interface().(string)

		case "edge_type":
			c.Edge_type = baml.Decode(valueHolder).Interface().(EdgeType)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class DependencyEdge", key))

		}
	}

}

func (c DependencyEdge) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["from_id"] = c.From_id

	fields["to_id"] = c.To_id

	fields["edge_type"] = c.Edge_type

	return baml.EncodeClass("DependencyEdge", fields, nil)
}

func (c DependencyEdge) BamlTypeName() string {
	return "DependencyEdge"
}

type DependencyGraph struct {
	Nodes []DependencyNode `json:"nodes"`
	Edges []DependencyEdge `json:"edges"`
}

func (c *DependencyGraph) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DependencyGraph" {
		panic(fmt.Sprintf("expected DependencyGraph, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "nodes":
			c.Nodes = baml.Decode(valueHolder).Interface().([]DependencyNode)

		case "edges":
			c.Edges = baml.Decode(valueHolder).Interface().([]DependencyEdge)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class DependencyGraph", key))

		}
	}

}

func (c DependencyGraph) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["nodes"] = c.Nodes

	fields["edges"] = c.Edges

	return baml.EncodeClass("DependencyGraph", fields, nil)
}

func (c DependencyGraph) BamlTypeName() string {
	return "DependencyGraph"
}

type DependencyNode struct {
	Id        string   `json:"id"`
	Path      string   `json:"path"`
	Symbol    *string  `json:"symbol"`
	Node_type NodeType `json:"node_type"`
}

func (c *DependencyNode) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DependencyNode" {
		panic(fmt.Sprintf("expected DependencyNode, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "id":
			c.Id = baml.Decode(valueHolder).Interface().(string)

		case "path":
			c.Path = baml.Decode(valueHolder).Interface().(string)

		case "symbol":
			c.Symbol = baml.Decode(valueHolder).Interface().(*string)

		case "node_type":
			c.Node_type = baml.Decode(valueHolder).Interface().(NodeType)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class DependencyNode", key))

		}
	}

}

func (c DependencyNode) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["id"] = c.Id

	fields["path"] = c.Path

	fields["symbol"] = c.Symbol

	fields["node_type"] = c.Node_type

	return baml.EncodeClass("DependencyNode", fields, nil)
}

func (c DependencyNode) BamlTypeName() string {
	return "DependencyNode"
}

type FeatureSpecification struct {
	Title               string          `json:"title"`
	Description         string          `json:"description"`
	Acceptance_criteria *[]string       `json:"acceptance_criteria"`
	Path_hints          *[]string       `json:"path_hints"`
	Additional_context  *string         `json:"additional_context"`
	Category            FeatureCategory `json:"category"`
}

func (c *FeatureSpecification) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "FeatureSpecification" {
		panic(fmt.Sprintf("expected FeatureSpecification, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "title":
			c.Title = baml.Decode(valueHolder).Interface().(string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "acceptance_criteria":
			c.Acceptance_criteria = baml.Decode(valueHolder).Interface().(*[]string)

		case "path_hints":
			c.Path_hints = baml.Decode(valueHolder).Interface().(*[]string)

		case "additional_context":
			c.Additional_context = baml.Decode(valueHolder).Interface().(*string)

		case "category":
			c.Category = baml.Decode(valueHolder).Interface().(FeatureCategory)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class FeatureSpecification", key))

		}
	}

}

func (c FeatureSpecification) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["title"] = c.Title

	fields["description"] = c.Description

	fields["acceptance_criteria"] = c.Acceptance_criteria

	fields["path_hints"] = c.Path_hints

	fields["additional_context"] = c.Additional_context

	fields["category"] = c.Category

	return baml.EncodeClass("FeatureSpecification", fields, nil)
}

func (c FeatureSpecification) BamlTypeName() string {
	return "FeatureSpecification"
}

type FileChange struct {
	File_path     string     `json:"file_path"`
	Action        FileAction `json:"action"`
	Previous_path *string    `json:"previous_path"`
	Content       *string    `json:"content"`
	Patch         *string    `json:"patch"`
	Description   string     `json:"description"`
}

func (c *FileChange) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "FileChange" {
		panic(fmt.Sprintf("expected FileChange, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(string)

		case "action":
			c.Action = baml.Decode(valueHolder).Interface().(FileAction)

		case "previous_path":
			c.Previous_path = baml.Decode(valueHolder).Interface().(*string)

		case "content":
			c.Content = baml.Decode(valueHolder).Interface().(*string)

		case "patch":
			c.Patch = baml.Decode(valueHolder).Interface().(*string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class FileChange", key))

		}
	}

}

func (c FileChange) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_path"] = c.File_path

	fields["action"] = c.Action

	fields["previous_path"] = c.Previous_path

	fields["content"] = c.Content

	fields["patch"] = c.Patch

	fields["description"] = c.Description

	return baml.EncodeClass("FileChange", fields, nil)
}

func (c FileChange) BamlTypeName() string {
	return "FileChange"
}

type FileImpact struct {
	File_path        string     `json:"file_path"`
	Impact_type      ImpactType `json:"impact_type"`
	Confidence       float64    `json:"confidence"`
	Rationale        string     `json:"rationale"`
	Affected_symbols *[]string  `json:"affected_symbols"`
}

func (c *FileImpact) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "FileImpact" {
		panic(fmt.Sprintf("expected FileImpact, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(string)

		case "impact_type":
			c.Impact_type = baml.Decode(valueHolder).Interface().(ImpactType)

		case "confidence":
			c.Confidence = baml.Decode(valueHolder).Float()

		case "rationale":
			c.Rationale = baml.Decode(valueHolder).Interface().(string)

		case "affected_symbols":
			c.Affected_symbols = baml.Decode(valueHolder).Interface().(*[]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class FileImpact", key))

		}
	}

}

func (c FileImpact) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_path"] = c.File_path

	fields["impact_type"] = c.Impact_type

	fields["confidence"] = c.Confidence

	fields["rationale"] = c.Rationale

	fields["affected_symbols"] = c.Affected_symbols

	return baml.EncodeClass("FileImpact", fields, nil)
}

func (c FileImpact) BamlTypeName() string {
	return "FileImpact"
}

type FileToReview struct {
	Path    string  `json:"path"`
	Content string  `json:"content"`
	Diff    *string `json:"diff"`
}

func (c *FileToReview) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "FileToReview" {
		panic(fmt.Sprintf("expected FileToReview, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "path":
			c.Path = baml.Decode(valueHolder).Interface().(string)

		case "content":
			c.Content = baml.Decode(valueHolder).Interface().(string)

		case "diff":
			c.Diff = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class FileToReview", key))

		}
	}

}

func (c FileToReview) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["path"] = c.Path

	fields["content"] = c.Content

	fields["diff"] = c.Diff

	return baml.EncodeClass("FileToReview", fields, nil)
}

func (c FileToReview) BamlTypeName() string {
	return "FileToReview"
}

type ImpactAnalysisResult struct {
	Direct_impacts   []FileImpact         `json:"direct_impacts"`
	Indirect_impacts []FileImpact         `json:"indirect_impacts"`
	Dependency_graph DependencyGraph      `json:"dependency_graph"`
	Test_coverage    TestCoverageAnalysis `json:"test_coverage"`
}

func (c *ImpactAnalysisResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ImpactAnalysisResult" {
		panic(fmt.Sprintf("expected ImpactAnalysisResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "direct_impacts":
			c.Direct_impacts = baml.Decode(valueHolder).Interface().([]FileImpact)

		case "indirect_impacts":
			c.Indirect_impacts = baml.Decode(valueHolder).Interface().([]FileImpact)

		case "dependency_graph":
			c.Dependency_graph = baml.Decode(valueHolder).Interface().(DependencyGraph)

		case "test_coverage":
			c.Test_coverage = baml.Decode(valueHolder).Interface().(TestCoverageAnalysis)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ImpactAnalysisResult", key))

		}
	}

}

func (c ImpactAnalysisResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["direct_impacts"] = c.Direct_impacts

	fields["indirect_impacts"] = c.Indirect_impacts

	fields["dependency_graph"] = c.Dependency_graph

	fields["test_coverage"] = c.Test_coverage

	return baml.EncodeClass("ImpactAnalysisResult", fields, nil)
}

func (c ImpactAnalysisResult) BamlTypeName() string {
	return "ImpactAnalysisResult"
}

type ImplementationPlan struct {
	Plan_id                 string           `json:"plan_id"`
	Title                   string           `json:"title"`
	Summary                 string           `json:"summary"`
	Steps                   []PlanStep       `json:"steps"`
	Dependencies            []StepDependency `json:"dependencies"`
	Estimated_metrics       PlanMetrics      `json:"estimated_metrics"`
	Assumptions             *[]string        `json:"assumptions"`
	Alternatives_considered *[]Alternative   `json:"alternatives_considered"`
}

func (c *ImplementationPlan) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ImplementationPlan" {
		panic(fmt.Sprintf("expected ImplementationPlan, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "plan_id":
			c.Plan_id = baml.Decode(valueHolder).Interface().(string)

		case "title":
			c.Title = baml.Decode(valueHolder).Interface().(string)

		case "summary":
			c.Summary = baml.Decode(valueHolder).Interface().(string)

		case "steps":
			c.Steps = baml.Decode(valueHolder).Interface().([]PlanStep)

		case "dependencies":
			c.Dependencies = baml.Decode(valueHolder).Interface().([]StepDependency)

		case "estimated_metrics":
			c.Estimated_metrics = baml.Decode(valueHolder).Interface().(PlanMetrics)

		case "assumptions":
			c.Assumptions = baml.Decode(valueHolder).Interface().(*[]string)

		case "alternatives_considered":
			c.Alternatives_considered = baml.Decode(valueHolder).Interface().(*[]Alternative)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ImplementationPlan", key))

		}
	}

}

func (c ImplementationPlan) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["plan_id"] = c.Plan_id

	fields["title"] = c.Title

	fields["summary"] = c.Summary

	fields["steps"] = c.Steps

	fields["dependencies"] = c.Dependencies

	fields["estimated_metrics"] = c.Estimated_metrics

	fields["assumptions"] = c.Assumptions

	fields["alternatives_considered"] = c.Alternatives_considered

	return baml.EncodeClass("ImplementationPlan", fields, nil)
}

func (c ImplementationPlan) BamlTypeName() string {
	return "ImplementationPlan"
}

type IterationContext struct {
	Build_output      *string `json:"build_output"`
	Test_output       *string `json:"test_output"`
	Lint_output       *string `json:"lint_output"`
	Previous_attempts int64   `json:"previous_attempts"`
}

func (c *IterationContext) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "IterationContext" {
		panic(fmt.Sprintf("expected IterationContext, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "build_output":
			c.Build_output = baml.Decode(valueHolder).Interface().(*string)

		case "test_output":
			c.Test_output = baml.Decode(valueHolder).Interface().(*string)

		case "lint_output":
			c.Lint_output = baml.Decode(valueHolder).Interface().(*string)

		case "previous_attempts":
			c.Previous_attempts = baml.Decode(valueHolder).Int()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class IterationContext", key))

		}
	}

}

func (c IterationContext) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["build_output"] = c.Build_output

	fields["test_output"] = c.Test_output

	fields["lint_output"] = c.Lint_output

	fields["previous_attempts"] = c.Previous_attempts

	return baml.EncodeClass("IterationContext", fields, nil)
}

func (c IterationContext) BamlTypeName() string {
	return "IterationContext"
}

type IterationIssue struct {
	Type        string  `json:"type"`
	File_path   *string `json:"file_path"`
	Line_number *int64  `json:"line_number"`
	Description string  `json:"description"`
	Severity    string  `json:"severity"`
}

func (c *IterationIssue) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "IterationIssue" {
		panic(fmt.Sprintf("expected IterationIssue, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(string)

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(*string)

		case "line_number":
			c.Line_number = baml.Decode(valueHolder).Interface().(*int64)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "severity":
			c.Severity = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class IterationIssue", key))

		}
	}

}

func (c IterationIssue) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["type"] = c.Type

	fields["file_path"] = c.File_path

	fields["line_number"] = c.Line_number

	fields["description"] = c.Description

	fields["severity"] = c.Severity

	return baml.EncodeClass("IterationIssue", fields, nil)
}

func (c IterationIssue) BamlTypeName() string {
	return "IterationIssue"
}

type IterationPlan struct {
	Strategy           IterationStrategy `json:"strategy"`
	Steps_to_retry     []int64           `json:"steps_to_retry"`
	Files_to_fix       []string          `json:"files_to_fix"`
	Additional_context *string           `json:"additional_context"`
}

func (c *IterationPlan) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "IterationPlan" {
		panic(fmt.Sprintf("expected IterationPlan, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "strategy":
			c.Strategy = baml.Decode(valueHolder).Interface().(IterationStrategy)

		case "steps_to_retry":
			c.Steps_to_retry = baml.Decode(valueHolder).Interface().([]int64)

		case "files_to_fix":
			c.Files_to_fix = baml.Decode(valueHolder).Interface().([]string)

		case "additional_context":
			c.Additional_context = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class IterationPlan", key))

		}
	}

}

func (c IterationPlan) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["strategy"] = c.Strategy

	fields["steps_to_retry"] = c.Steps_to_retry

	fields["files_to_fix"] = c.Files_to_fix

	fields["additional_context"] = c.Additional_context

	return baml.EncodeClass("IterationPlan", fields, nil)
}

func (c IterationPlan) BamlTypeName() string {
	return "IterationPlan"
}

type IterationRequest struct {
	Original_plan ImplementationPlan `json:"original_plan"`
	Failed_step   *int64             `json:"failed_step"`
	Issues        []IterationIssue   `json:"issues"`
	Context       IterationContext   `json:"context"`
}

func (c *IterationRequest) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "IterationRequest" {
		panic(fmt.Sprintf("expected IterationRequest, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "original_plan":
			c.Original_plan = baml.Decode(valueHolder).Interface().(ImplementationPlan)

		case "failed_step":
			c.Failed_step = baml.Decode(valueHolder).Interface().(*int64)

		case "issues":
			c.Issues = baml.Decode(valueHolder).Interface().([]IterationIssue)

		case "context":
			c.Context = baml.Decode(valueHolder).Interface().(IterationContext)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class IterationRequest", key))

		}
	}

}

func (c IterationRequest) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["original_plan"] = c.Original_plan

	fields["failed_step"] = c.Failed_step

	fields["issues"] = c.Issues

	fields["context"] = c.Context

	return baml.EncodeClass("IterationRequest", fields, nil)
}

func (c IterationRequest) BamlTypeName() string {
	return "IterationRequest"
}

type NormalizedSpecification struct {
	Problem_statement   string                `json:"problem_statement"`
	Behavior_changes    []BehaviorChange      `json:"behavior_changes"`
	Components          []ComponentReference  `json:"components"`
	Acceptance_criteria []AcceptanceCriterion `json:"acceptance_criteria"`
	Risks               []Risk                `json:"risks"`
	Complexity          ComplexityAssessment  `json:"complexity"`
}

func (c *NormalizedSpecification) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "NormalizedSpecification" {
		panic(fmt.Sprintf("expected NormalizedSpecification, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "problem_statement":
			c.Problem_statement = baml.Decode(valueHolder).Interface().(string)

		case "behavior_changes":
			c.Behavior_changes = baml.Decode(valueHolder).Interface().([]BehaviorChange)

		case "components":
			c.Components = baml.Decode(valueHolder).Interface().([]ComponentReference)

		case "acceptance_criteria":
			c.Acceptance_criteria = baml.Decode(valueHolder).Interface().([]AcceptanceCriterion)

		case "risks":
			c.Risks = baml.Decode(valueHolder).Interface().([]Risk)

		case "complexity":
			c.Complexity = baml.Decode(valueHolder).Interface().(ComplexityAssessment)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class NormalizedSpecification", key))

		}
	}

}

func (c NormalizedSpecification) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["problem_statement"] = c.Problem_statement

	fields["behavior_changes"] = c.Behavior_changes

	fields["components"] = c.Components

	fields["acceptance_criteria"] = c.Acceptance_criteria

	fields["risks"] = c.Risks

	fields["complexity"] = c.Complexity

	return baml.EncodeClass("NormalizedSpecification", fields, nil)
}

func (c NormalizedSpecification) BamlTypeName() string {
	return "NormalizedSpecification"
}

type PlanMetrics struct {
	Total_steps           int64 `json:"total_steps"`
	Estimated_tokens      int64 `json:"estimated_tokens"`
	Estimated_files_total int64 `json:"estimated_files_total"`
	Estimated_new_files   int64 `json:"estimated_new_files"`
	Estimated_modified    int64 `json:"estimated_modified"`
	Estimated_deleted     int64 `json:"estimated_deleted"`
}

func (c *PlanMetrics) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "PlanMetrics" {
		panic(fmt.Sprintf("expected PlanMetrics, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "total_steps":
			c.Total_steps = baml.Decode(valueHolder).Int()

		case "estimated_tokens":
			c.Estimated_tokens = baml.Decode(valueHolder).Int()

		case "estimated_files_total":
			c.Estimated_files_total = baml.Decode(valueHolder).Int()

		case "estimated_new_files":
			c.Estimated_new_files = baml.Decode(valueHolder).Int()

		case "estimated_modified":
			c.Estimated_modified = baml.Decode(valueHolder).Int()

		case "estimated_deleted":
			c.Estimated_deleted = baml.Decode(valueHolder).Int()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class PlanMetrics", key))

		}
	}

}

func (c PlanMetrics) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["total_steps"] = c.Total_steps

	fields["estimated_tokens"] = c.Estimated_tokens

	fields["estimated_files_total"] = c.Estimated_files_total

	fields["estimated_new_files"] = c.Estimated_new_files

	fields["estimated_modified"] = c.Estimated_modified

	fields["estimated_deleted"] = c.Estimated_deleted

	return baml.EncodeClass("PlanMetrics", fields, nil)
}

func (c PlanMetrics) BamlTypeName() string {
	return "PlanMetrics"
}

type PlanStep struct {
	Step_number      int64            `json:"step_number"`
	Action           string           `json:"action"`
	Rationale        string           `json:"rationale"`
	Target_files     []TargetFile     `json:"target_files"`
	Prerequisites    *[]int64         `json:"prerequisites"`
	Expected_outcome string           `json:"expected_outcome"`
	Verification     StepVerification `json:"verification"`
	Estimated_tokens int64            `json:"estimated_tokens"`
}

func (c *PlanStep) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "PlanStep" {
		panic(fmt.Sprintf("expected PlanStep, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "step_number":
			c.Step_number = baml.Decode(valueHolder).Int()

		case "action":
			c.Action = baml.Decode(valueHolder).Interface().(string)

		case "rationale":
			c.Rationale = baml.Decode(valueHolder).Interface().(string)

		case "target_files":
			c.Target_files = baml.Decode(valueHolder).Interface().([]TargetFile)

		case "prerequisites":
			c.Prerequisites = baml.Decode(valueHolder).Interface().(*[]int64)

		case "expected_outcome":
			c.Expected_outcome = baml.Decode(valueHolder).Interface().(string)

		case "verification":
			c.Verification = baml.Decode(valueHolder).Interface().(StepVerification)

		case "estimated_tokens":
			c.Estimated_tokens = baml.Decode(valueHolder).Int()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class PlanStep", key))

		}
	}

}

func (c PlanStep) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["step_number"] = c.Step_number

	fields["action"] = c.Action

	fields["rationale"] = c.Rationale

	fields["target_files"] = c.Target_files

	fields["prerequisites"] = c.Prerequisites

	fields["expected_outcome"] = c.Expected_outcome

	fields["verification"] = c.Verification

	fields["estimated_tokens"] = c.Estimated_tokens

	return baml.EncodeClass("PlanStep", fields, nil)
}

func (c PlanStep) BamlTypeName() string {
	return "PlanStep"
}

type ReviewAssessment struct {
	Overall_score  int64                `json:"overall_score"`
	Recommendation ReviewRecommendation `json:"recommendation"`
	Summary        string               `json:"summary"`
	Issues         []ReviewIssue        `json:"issues"`
	Suggestions    []ReviewSuggestion   `json:"suggestions"`
	Metrics        CodeQualityMetrics   `json:"metrics"`
}

func (c *ReviewAssessment) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ReviewAssessment" {
		panic(fmt.Sprintf("expected ReviewAssessment, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "overall_score":
			c.Overall_score = baml.Decode(valueHolder).Int()

		case "recommendation":
			c.Recommendation = baml.Decode(valueHolder).Interface().(ReviewRecommendation)

		case "summary":
			c.Summary = baml.Decode(valueHolder).Interface().(string)

		case "issues":
			c.Issues = baml.Decode(valueHolder).Interface().([]ReviewIssue)

		case "suggestions":
			c.Suggestions = baml.Decode(valueHolder).Interface().([]ReviewSuggestion)

		case "metrics":
			c.Metrics = baml.Decode(valueHolder).Interface().(CodeQualityMetrics)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ReviewAssessment", key))

		}
	}

}

func (c ReviewAssessment) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["overall_score"] = c.Overall_score

	fields["recommendation"] = c.Recommendation

	fields["summary"] = c.Summary

	fields["issues"] = c.Issues

	fields["suggestions"] = c.Suggestions

	fields["metrics"] = c.Metrics

	return baml.EncodeClass("ReviewAssessment", fields, nil)
}

func (c ReviewAssessment) BamlTypeName() string {
	return "ReviewAssessment"
}

type ReviewContext struct {
	Feature_description string   `json:"feature_description"`
	Acceptance_criteria []string `json:"acceptance_criteria"`
	Language            string   `json:"language"`
	Coding_standards    *string  `json:"coding_standards"`
}

func (c *ReviewContext) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ReviewContext" {
		panic(fmt.Sprintf("expected ReviewContext, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "feature_description":
			c.Feature_description = baml.Decode(valueHolder).Interface().(string)

		case "acceptance_criteria":
			c.Acceptance_criteria = baml.Decode(valueHolder).Interface().([]string)

		case "language":
			c.Language = baml.Decode(valueHolder).Interface().(string)

		case "coding_standards":
			c.Coding_standards = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ReviewContext", key))

		}
	}

}

func (c ReviewContext) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["feature_description"] = c.Feature_description

	fields["acceptance_criteria"] = c.Acceptance_criteria

	fields["language"] = c.Language

	fields["coding_standards"] = c.Coding_standards

	return baml.EncodeClass("ReviewContext", fields, nil)
}

func (c ReviewContext) BamlTypeName() string {
	return "ReviewContext"
}

type ReviewIssue struct {
	Id           string              `json:"id"`
	Type         ReviewIssueType     `json:"type"`
	Severity     ReviewIssueSeverity `json:"severity"`
	File_path    string              `json:"file_path"`
	Line_start   int64               `json:"line_start"`
	Line_end     int64               `json:"line_end"`
	Title        string              `json:"title"`
	Description  string              `json:"description"`
	Suggestion   *string             `json:"suggestion"`
	Code_snippet *string             `json:"code_snippet"`
}

func (c *ReviewIssue) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ReviewIssue" {
		panic(fmt.Sprintf("expected ReviewIssue, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "id":
			c.Id = baml.Decode(valueHolder).Interface().(string)

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(ReviewIssueType)

		case "severity":
			c.Severity = baml.Decode(valueHolder).Interface().(ReviewIssueSeverity)

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(string)

		case "line_start":
			c.Line_start = baml.Decode(valueHolder).Int()

		case "line_end":
			c.Line_end = baml.Decode(valueHolder).Int()

		case "title":
			c.Title = baml.Decode(valueHolder).Interface().(string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "suggestion":
			c.Suggestion = baml.Decode(valueHolder).Interface().(*string)

		case "code_snippet":
			c.Code_snippet = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ReviewIssue", key))

		}
	}

}

func (c ReviewIssue) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["id"] = c.Id

	fields["type"] = c.Type

	fields["severity"] = c.Severity

	fields["file_path"] = c.File_path

	fields["line_start"] = c.Line_start

	fields["line_end"] = c.Line_end

	fields["title"] = c.Title

	fields["description"] = c.Description

	fields["suggestion"] = c.Suggestion

	fields["code_snippet"] = c.Code_snippet

	return baml.EncodeClass("ReviewIssue", fields, nil)
}

func (c ReviewIssue) BamlTypeName() string {
	return "ReviewIssue"
}

type ReviewRequest struct {
	Files_to_review []FileToReview `json:"files_to_review"`
	Context         ReviewContext  `json:"context"`
}

func (c *ReviewRequest) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ReviewRequest" {
		panic(fmt.Sprintf("expected ReviewRequest, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "files_to_review":
			c.Files_to_review = baml.Decode(valueHolder).Interface().([]FileToReview)

		case "context":
			c.Context = baml.Decode(valueHolder).Interface().(ReviewContext)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ReviewRequest", key))

		}
	}

}

func (c ReviewRequest) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["files_to_review"] = c.Files_to_review

	fields["context"] = c.Context

	return baml.EncodeClass("ReviewRequest", fields, nil)
}

func (c ReviewRequest) BamlTypeName() string {
	return "ReviewRequest"
}

type ReviewSuggestion struct {
	Title       string  `json:"title"`
	Description string  `json:"description"`
	File_path   *string `json:"file_path"`
	Line_number *int64  `json:"line_number"`
	Priority    string  `json:"priority"`
}

func (c *ReviewSuggestion) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ReviewSuggestion" {
		panic(fmt.Sprintf("expected ReviewSuggestion, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "title":
			c.Title = baml.Decode(valueHolder).Interface().(string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(*string)

		case "line_number":
			c.Line_number = baml.Decode(valueHolder).Interface().(*int64)

		case "priority":
			c.Priority = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ReviewSuggestion", key))

		}
	}

}

func (c ReviewSuggestion) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["title"] = c.Title

	fields["description"] = c.Description

	fields["file_path"] = c.File_path

	fields["line_number"] = c.Line_number

	fields["priority"] = c.Priority

	return baml.EncodeClass("ReviewSuggestion", fields, nil)
}

func (c ReviewSuggestion) BamlTypeName() string {
	return "ReviewSuggestion"
}

type Risk struct {
	Description string    `json:"description"`
	Level       RiskLevel `json:"level"`
	Mitigation  string    `json:"mitigation"`
}

func (c *Risk) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Risk" {
		panic(fmt.Sprintf("expected Risk, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "level":
			c.Level = baml.Decode(valueHolder).Interface().(RiskLevel)

		case "mitigation":
			c.Mitigation = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class Risk", key))

		}
	}

}

func (c Risk) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["description"] = c.Description

	fields["level"] = c.Level

	fields["mitigation"] = c.Mitigation

	return baml.EncodeClass("Risk", fields, nil)
}

func (c Risk) BamlTypeName() string {
	return "Risk"
}

type StepDependency struct {
	From_step       int64          `json:"from_step"`
	To_step         int64          `json:"to_step"`
	Dependency_type DependencyKind `json:"dependency_type"`
	Reason          string         `json:"reason"`
}

func (c *StepDependency) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "StepDependency" {
		panic(fmt.Sprintf("expected StepDependency, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "from_step":
			c.From_step = baml.Decode(valueHolder).Int()

		case "to_step":
			c.To_step = baml.Decode(valueHolder).Int()

		case "dependency_type":
			c.Dependency_type = baml.Decode(valueHolder).Interface().(DependencyKind)

		case "reason":
			c.Reason = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class StepDependency", key))

		}
	}

}

func (c StepDependency) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["from_step"] = c.From_step

	fields["to_step"] = c.To_step

	fields["dependency_type"] = c.Dependency_type

	fields["reason"] = c.Reason

	return baml.EncodeClass("StepDependency", fields, nil)
}

func (c StepDependency) BamlTypeName() string {
	return "StepDependency"
}

type StepVerification struct {
	Method      VerificationMethod `json:"method"`
	Command     *string            `json:"command"`
	Expected    *string            `json:"expected"`
	Description string             `json:"description"`
}

func (c *StepVerification) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "StepVerification" {
		panic(fmt.Sprintf("expected StepVerification, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "method":
			c.Method = baml.Decode(valueHolder).Interface().(VerificationMethod)

		case "command":
			c.Command = baml.Decode(valueHolder).Interface().(*string)

		case "expected":
			c.Expected = baml.Decode(valueHolder).Interface().(*string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class StepVerification", key))

		}
	}

}

func (c StepVerification) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["method"] = c.Method

	fields["command"] = c.Command

	fields["expected"] = c.Expected

	fields["description"] = c.Description

	return baml.EncodeClass("StepVerification", fields, nil)
}

func (c StepVerification) BamlTypeName() string {
	return "StepVerification"
}

type TargetFile struct {
	Path        string         `json:"path"`
	Action      FileAction     `json:"action"`
	Change_type FileChangeType `json:"change_type"`
	Reason      string         `json:"reason"`
}

func (c *TargetFile) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TargetFile" {
		panic(fmt.Sprintf("expected TargetFile, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "path":
			c.Path = baml.Decode(valueHolder).Interface().(string)

		case "action":
			c.Action = baml.Decode(valueHolder).Interface().(FileAction)

		case "change_type":
			c.Change_type = baml.Decode(valueHolder).Interface().(FileChangeType)

		case "reason":
			c.Reason = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TargetFile", key))

		}
	}

}

func (c TargetFile) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["path"] = c.Path

	fields["action"] = c.Action

	fields["change_type"] = c.Change_type

	fields["reason"] = c.Reason

	return baml.EncodeClass("TargetFile", fields, nil)
}

func (c TargetFile) BamlTypeName() string {
	return "TargetFile"
}

type TestCase struct {
	Name            string   `json:"name"`
	Description     string   `json:"description"`
	Test_type       TestType `json:"test_type"`
	Target_function string   `json:"target_function"`
}

func (c *TestCase) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestCase" {
		panic(fmt.Sprintf("expected TestCase, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		case "test_type":
			c.Test_type = baml.Decode(valueHolder).Interface().(TestType)

		case "target_function":
			c.Target_function = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestCase", key))

		}
	}

}

func (c TestCase) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["name"] = c.Name

	fields["description"] = c.Description

	fields["test_type"] = c.Test_type

	fields["target_function"] = c.Target_function

	return baml.EncodeClass("TestCase", fields, nil)
}

func (c TestCase) BamlTypeName() string {
	return "TestCase"
}

type TestCoverageAnalysis struct {
	Covering_tests  []TestReference      `json:"covering_tests"`
	Coverage_gaps   []CoverageGap        `json:"coverage_gaps"`
	Recommendations []TestRecommendation `json:"recommendations"`
}

func (c *TestCoverageAnalysis) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestCoverageAnalysis" {
		panic(fmt.Sprintf("expected TestCoverageAnalysis, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "covering_tests":
			c.Covering_tests = baml.Decode(valueHolder).Interface().([]TestReference)

		case "coverage_gaps":
			c.Coverage_gaps = baml.Decode(valueHolder).Interface().([]CoverageGap)

		case "recommendations":
			c.Recommendations = baml.Decode(valueHolder).Interface().([]TestRecommendation)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestCoverageAnalysis", key))

		}
	}

}

func (c TestCoverageAnalysis) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["covering_tests"] = c.Covering_tests

	fields["coverage_gaps"] = c.Coverage_gaps

	fields["recommendations"] = c.Recommendations

	return baml.EncodeClass("TestCoverageAnalysis", fields, nil)
}

func (c TestCoverageAnalysis) BamlTypeName() string {
	return "TestCoverageAnalysis"
}

type TestGenerationRequest struct {
	Target_file     string  `json:"target_file"`
	Target_content  string  `json:"target_content"`
	Existing_tests  *string `json:"existing_tests"`
	Test_framework  string  `json:"test_framework"`
	Coverage_target float64 `json:"coverage_target"`
}

func (c *TestGenerationRequest) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestGenerationRequest" {
		panic(fmt.Sprintf("expected TestGenerationRequest, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "target_file":
			c.Target_file = baml.Decode(valueHolder).Interface().(string)

		case "target_content":
			c.Target_content = baml.Decode(valueHolder).Interface().(string)

		case "existing_tests":
			c.Existing_tests = baml.Decode(valueHolder).Interface().(*string)

		case "test_framework":
			c.Test_framework = baml.Decode(valueHolder).Interface().(string)

		case "coverage_target":
			c.Coverage_target = baml.Decode(valueHolder).Float()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestGenerationRequest", key))

		}
	}

}

func (c TestGenerationRequest) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["target_file"] = c.Target_file

	fields["target_content"] = c.Target_content

	fields["existing_tests"] = c.Existing_tests

	fields["test_framework"] = c.Test_framework

	fields["coverage_target"] = c.Coverage_target

	return baml.EncodeClass("TestGenerationRequest", fields, nil)
}

func (c TestGenerationRequest) BamlTypeName() string {
	return "TestGenerationRequest"
}

type TestGenerationResult struct {
	Test_file_path    string     `json:"test_file_path"`
	Test_content      string     `json:"test_content"`
	Test_cases        []TestCase `json:"test_cases"`
	Coverage_estimate float64    `json:"coverage_estimate"`
}

func (c *TestGenerationResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestGenerationResult" {
		panic(fmt.Sprintf("expected TestGenerationResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "test_file_path":
			c.Test_file_path = baml.Decode(valueHolder).Interface().(string)

		case "test_content":
			c.Test_content = baml.Decode(valueHolder).Interface().(string)

		case "test_cases":
			c.Test_cases = baml.Decode(valueHolder).Interface().([]TestCase)

		case "coverage_estimate":
			c.Coverage_estimate = baml.Decode(valueHolder).Float()

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestGenerationResult", key))

		}
	}

}

func (c TestGenerationResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["test_file_path"] = c.Test_file_path

	fields["test_content"] = c.Test_content

	fields["test_cases"] = c.Test_cases

	fields["coverage_estimate"] = c.Coverage_estimate

	return baml.EncodeClass("TestGenerationResult", fields, nil)
}

func (c TestGenerationResult) BamlTypeName() string {
	return "TestGenerationResult"
}

type TestRecommendation struct {
	Target_file   string `json:"target_file"`
	Target_symbol string `json:"target_symbol"`
	Test_type     string `json:"test_type"`
	Description   string `json:"description"`
}

func (c *TestRecommendation) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestRecommendation" {
		panic(fmt.Sprintf("expected TestRecommendation, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "target_file":
			c.Target_file = baml.Decode(valueHolder).Interface().(string)

		case "target_symbol":
			c.Target_symbol = baml.Decode(valueHolder).Interface().(string)

		case "test_type":
			c.Test_type = baml.Decode(valueHolder).Interface().(string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestRecommendation", key))

		}
	}

}

func (c TestRecommendation) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["target_file"] = c.Target_file

	fields["target_symbol"] = c.Target_symbol

	fields["test_type"] = c.Test_type

	fields["description"] = c.Description

	return baml.EncodeClass("TestRecommendation", fields, nil)
}

func (c TestRecommendation) BamlTypeName() string {
	return "TestRecommendation"
}

type TestReference struct {
	File_path    string   `json:"file_path"`
	Test_name    string   `json:"test_name"`
	Covers_files []string `json:"covers_files"`
}

func (c *TestReference) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TestReference" {
		panic(fmt.Sprintf("expected TestReference, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "file_path":
			c.File_path = baml.Decode(valueHolder).Interface().(string)

		case "test_name":
			c.Test_name = baml.Decode(valueHolder).Interface().(string)

		case "covers_files":
			c.Covers_files = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TestReference", key))

		}
	}

}

func (c TestReference) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["file_path"] = c.File_path

	fields["test_name"] = c.Test_name

	fields["covers_files"] = c.Covers_files

	return baml.EncodeClass("TestReference", fields, nil)
}

func (c TestReference) BamlTypeName() string {
	return "TestReference"
}
