// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
	"encoding/json"
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type ChangeType string

const (
	ChangeTypeAdd      ChangeType = "Add"
	ChangeTypeModify   ChangeType = "Modify"
	ChangeTypeRemove   ChangeType = "Remove"
	ChangeTypeRefactor ChangeType = "Refactor"
)

// Values returns all allowed values for the ChangeType type.
func (ChangeType) Values() []ChangeType {
	return []ChangeType{
		ChangeTypeAdd,
		ChangeTypeModify,
		ChangeTypeRemove,
		ChangeTypeRefactor,
	}
}

// IsValid checks whether the given ChangeType value is valid.
func (e ChangeType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ChangeType.
func (e ChangeType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ChangeType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ChangeType.
func (e *ChangeType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ChangeType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ChangeType: %q", s)
	}
	return nil
}

func (e *ChangeType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ChangeType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ChangeType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ChangeType(value)
}

func (e ChangeType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ChangeType", string(e), false)
}

func (e ChangeType) BamlTypeName() string {
	return "ChangeType"
}

type CommitType string

const (
	CommitTypeFeat     CommitType = "Feat"
	CommitTypeFix      CommitType = "Fix"
	CommitTypeRefactor CommitType = "Refactor"
	CommitTypeTest     CommitType = "Test"
	CommitTypeDocs     CommitType = "Docs"
	CommitTypeChore    CommitType = "Chore"
	CommitTypeStyle    CommitType = "Style"
	CommitTypePerf     CommitType = "Perf"
)

// Values returns all allowed values for the CommitType type.
func (CommitType) Values() []CommitType {
	return []CommitType{
		CommitTypeFeat,
		CommitTypeFix,
		CommitTypeRefactor,
		CommitTypeTest,
		CommitTypeDocs,
		CommitTypeChore,
		CommitTypeStyle,
		CommitTypePerf,
	}
}

// IsValid checks whether the given CommitType value is valid.
func (e CommitType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for CommitType.
func (e CommitType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid CommitType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for CommitType.
func (e *CommitType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = CommitType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid CommitType: %q", s)
	}
	return nil
}

func (e *CommitType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "CommitType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.CommitType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = CommitType(value)
}

func (e CommitType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("CommitType", string(e), false)
}

func (e CommitType) BamlTypeName() string {
	return "CommitType"
}

type ComplexityLevel string

const (
	ComplexityLevelTrivial     ComplexityLevel = "Trivial"
	ComplexityLevelSimple      ComplexityLevel = "Simple"
	ComplexityLevelModerate    ComplexityLevel = "Moderate"
	ComplexityLevelComplex     ComplexityLevel = "Complex"
	ComplexityLevelVeryComplex ComplexityLevel = "VeryComplex"
)

// Values returns all allowed values for the ComplexityLevel type.
func (ComplexityLevel) Values() []ComplexityLevel {
	return []ComplexityLevel{
		ComplexityLevelTrivial,
		ComplexityLevelSimple,
		ComplexityLevelModerate,
		ComplexityLevelComplex,
		ComplexityLevelVeryComplex,
	}
}

// IsValid checks whether the given ComplexityLevel value is valid.
func (e ComplexityLevel) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ComplexityLevel.
func (e ComplexityLevel) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ComplexityLevel: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ComplexityLevel.
func (e *ComplexityLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ComplexityLevel(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ComplexityLevel: %q", s)
	}
	return nil
}

func (e *ComplexityLevel) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ComplexityLevel" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ComplexityLevel, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ComplexityLevel(value)
}

func (e ComplexityLevel) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ComplexityLevel", string(e), false)
}

func (e ComplexityLevel) BamlTypeName() string {
	return "ComplexityLevel"
}

type ComponentType string

const (
	ComponentTypeFile     ComponentType = "File"
	ComponentTypeFunction ComponentType = "Function"
	ComponentTypeClass    ComponentType = "Class"
	ComponentTypeModule   ComponentType = "Module"
	ComponentTypePackage  ComponentType = "Package"
	ComponentTypeConfig   ComponentType = "Config"
	ComponentTypeTest     ComponentType = "Test"
)

// Values returns all allowed values for the ComponentType type.
func (ComponentType) Values() []ComponentType {
	return []ComponentType{
		ComponentTypeFile,
		ComponentTypeFunction,
		ComponentTypeClass,
		ComponentTypeModule,
		ComponentTypePackage,
		ComponentTypeConfig,
		ComponentTypeTest,
	}
}

// IsValid checks whether the given ComponentType value is valid.
func (e ComponentType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ComponentType.
func (e ComponentType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ComponentType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ComponentType.
func (e *ComponentType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ComponentType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ComponentType: %q", s)
	}
	return nil
}

func (e *ComponentType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ComponentType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ComponentType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ComponentType(value)
}

func (e ComponentType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ComponentType", string(e), false)
}

func (e ComponentType) BamlTypeName() string {
	return "ComponentType"
}

type DependencyKind string

const (
	DependencyKindStrict DependencyKind = "Strict"
	DependencyKindSoft   DependencyKind = "Soft"
	DependencyKindData   DependencyKind = "Data"
)

// Values returns all allowed values for the DependencyKind type.
func (DependencyKind) Values() []DependencyKind {
	return []DependencyKind{
		DependencyKindStrict,
		DependencyKindSoft,
		DependencyKindData,
	}
}

// IsValid checks whether the given DependencyKind value is valid.
func (e DependencyKind) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for DependencyKind.
func (e DependencyKind) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid DependencyKind: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for DependencyKind.
func (e *DependencyKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = DependencyKind(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid DependencyKind: %q", s)
	}
	return nil
}

func (e *DependencyKind) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "DependencyKind" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.DependencyKind, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = DependencyKind(value)
}

func (e DependencyKind) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("DependencyKind", string(e), false)
}

func (e DependencyKind) BamlTypeName() string {
	return "DependencyKind"
}

type EdgeType string

const (
	EdgeTypeImports    EdgeType = "Imports"
	EdgeTypeCalls      EdgeType = "Calls"
	EdgeTypeExtends    EdgeType = "Extends"
	EdgeTypeImplements EdgeType = "Implements"
	EdgeTypeUses       EdgeType = "Uses"
)

// Values returns all allowed values for the EdgeType type.
func (EdgeType) Values() []EdgeType {
	return []EdgeType{
		EdgeTypeImports,
		EdgeTypeCalls,
		EdgeTypeExtends,
		EdgeTypeImplements,
		EdgeTypeUses,
	}
}

// IsValid checks whether the given EdgeType value is valid.
func (e EdgeType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for EdgeType.
func (e EdgeType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid EdgeType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for EdgeType.
func (e *EdgeType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = EdgeType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid EdgeType: %q", s)
	}
	return nil
}

func (e *EdgeType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "EdgeType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.EdgeType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = EdgeType(value)
}

func (e EdgeType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("EdgeType", string(e), false)
}

func (e EdgeType) BamlTypeName() string {
	return "EdgeType"
}

type FeatureCategory string

const (
	FeatureCategoryNewFeature    FeatureCategory = "NewFeature"
	FeatureCategoryBugFix        FeatureCategory = "BugFix"
	FeatureCategoryRefactor      FeatureCategory = "Refactor"
	FeatureCategoryDocumentation FeatureCategory = "Documentation"
	FeatureCategoryTest          FeatureCategory = "Test"
	FeatureCategoryDependency    FeatureCategory = "Dependency"
)

// Values returns all allowed values for the FeatureCategory type.
func (FeatureCategory) Values() []FeatureCategory {
	return []FeatureCategory{
		FeatureCategoryNewFeature,
		FeatureCategoryBugFix,
		FeatureCategoryRefactor,
		FeatureCategoryDocumentation,
		FeatureCategoryTest,
		FeatureCategoryDependency,
	}
}

// IsValid checks whether the given FeatureCategory value is valid.
func (e FeatureCategory) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for FeatureCategory.
func (e FeatureCategory) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid FeatureCategory: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for FeatureCategory.
func (e *FeatureCategory) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = FeatureCategory(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid FeatureCategory: %q", s)
	}
	return nil
}

func (e *FeatureCategory) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "FeatureCategory" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.FeatureCategory, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = FeatureCategory(value)
}

func (e FeatureCategory) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("FeatureCategory", string(e), false)
}

func (e FeatureCategory) BamlTypeName() string {
	return "FeatureCategory"
}

type FileAction string

const (
	FileActionCreate FileAction = "Create"
	FileActionModify FileAction = "Modify"
	FileActionDelete FileAction = "Delete"
	FileActionRename FileAction = "Rename"
)

// Values returns all allowed values for the FileAction type.
func (FileAction) Values() []FileAction {
	return []FileAction{
		FileActionCreate,
		FileActionModify,
		FileActionDelete,
		FileActionRename,
	}
}

// IsValid checks whether the given FileAction value is valid.
func (e FileAction) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for FileAction.
func (e FileAction) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid FileAction: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for FileAction.
func (e *FileAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = FileAction(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid FileAction: %q", s)
	}
	return nil
}

func (e *FileAction) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "FileAction" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.FileAction, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = FileAction(value)
}

func (e FileAction) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("FileAction", string(e), false)
}

func (e FileAction) BamlTypeName() string {
	return "FileAction"
}

type FileChangeType string

const (
	FileChangeTypeImplementation FileChangeType = "Implementation"
	FileChangeTypeTest           FileChangeType = "Test"
	FileChangeTypeConfig         FileChangeType = "Config"
	FileChangeTypeDocumentation  FileChangeType = "Documentation"
	FileChangeTypeDependency     FileChangeType = "Dependency"
)

// Values returns all allowed values for the FileChangeType type.
func (FileChangeType) Values() []FileChangeType {
	return []FileChangeType{
		FileChangeTypeImplementation,
		FileChangeTypeTest,
		FileChangeTypeConfig,
		FileChangeTypeDocumentation,
		FileChangeTypeDependency,
	}
}

// IsValid checks whether the given FileChangeType value is valid.
func (e FileChangeType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for FileChangeType.
func (e FileChangeType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid FileChangeType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for FileChangeType.
func (e *FileChangeType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = FileChangeType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid FileChangeType: %q", s)
	}
	return nil
}

func (e *FileChangeType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "FileChangeType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.FileChangeType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = FileChangeType(value)
}

func (e FileChangeType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("FileChangeType", string(e), false)
}

func (e FileChangeType) BamlTypeName() string {
	return "FileChangeType"
}

type ImpactType string

const (
	ImpactTypeCreate     ImpactType = "Create"
	ImpactTypeModify     ImpactType = "Modify"
	ImpactTypeDelete     ImpactType = "Delete"
	ImpactTypeRename     ImpactType = "Rename"
	ImpactTypeDependency ImpactType = "Dependency"
)

// Values returns all allowed values for the ImpactType type.
func (ImpactType) Values() []ImpactType {
	return []ImpactType{
		ImpactTypeCreate,
		ImpactTypeModify,
		ImpactTypeDelete,
		ImpactTypeRename,
		ImpactTypeDependency,
	}
}

// IsValid checks whether the given ImpactType value is valid.
func (e ImpactType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ImpactType.
func (e ImpactType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ImpactType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ImpactType.
func (e *ImpactType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ImpactType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ImpactType: %q", s)
	}
	return nil
}

func (e *ImpactType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ImpactType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ImpactType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ImpactType(value)
}

func (e ImpactType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ImpactType", string(e), false)
}

func (e ImpactType) BamlTypeName() string {
	return "ImpactType"
}

type IterationStrategy string

const (
	IterationStrategyFix     IterationStrategy = "Fix"
	IterationStrategyRetry   IterationStrategy = "Retry"
	IterationStrategyReplan  IterationStrategy = "Replan"
	IterationStrategyPartial IterationStrategy = "Partial"
)

// Values returns all allowed values for the IterationStrategy type.
func (IterationStrategy) Values() []IterationStrategy {
	return []IterationStrategy{
		IterationStrategyFix,
		IterationStrategyRetry,
		IterationStrategyReplan,
		IterationStrategyPartial,
	}
}

// IsValid checks whether the given IterationStrategy value is valid.
func (e IterationStrategy) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for IterationStrategy.
func (e IterationStrategy) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid IterationStrategy: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for IterationStrategy.
func (e *IterationStrategy) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = IterationStrategy(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid IterationStrategy: %q", s)
	}
	return nil
}

func (e *IterationStrategy) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "IterationStrategy" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.IterationStrategy, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = IterationStrategy(value)
}

func (e IterationStrategy) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("IterationStrategy", string(e), false)
}

func (e IterationStrategy) BamlTypeName() string {
	return "IterationStrategy"
}

type NodeType string

const (
	NodeTypeFile     NodeType = "File"
	NodeTypeFunction NodeType = "Function"
	NodeTypeClass    NodeType = "Class"
	NodeTypeVariable NodeType = "Variable"
	NodeTypeType     NodeType = "Type"
)

// Values returns all allowed values for the NodeType type.
func (NodeType) Values() []NodeType {
	return []NodeType{
		NodeTypeFile,
		NodeTypeFunction,
		NodeTypeClass,
		NodeTypeVariable,
		NodeTypeType,
	}
}

// IsValid checks whether the given NodeType value is valid.
func (e NodeType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for NodeType.
func (e NodeType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid NodeType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for NodeType.
func (e *NodeType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = NodeType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid NodeType: %q", s)
	}
	return nil
}

func (e *NodeType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "NodeType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.NodeType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = NodeType(value)
}

func (e NodeType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("NodeType", string(e), false)
}

func (e NodeType) BamlTypeName() string {
	return "NodeType"
}

type ReviewIssueSeverity string

const (
	ReviewIssueSeverityInfo     ReviewIssueSeverity = "Info"
	ReviewIssueSeverityLow      ReviewIssueSeverity = "Low"
	ReviewIssueSeverityMedium   ReviewIssueSeverity = "Medium"
	ReviewIssueSeverityHigh     ReviewIssueSeverity = "High"
	ReviewIssueSeverityCritical ReviewIssueSeverity = "Critical"
)

// Values returns all allowed values for the ReviewIssueSeverity type.
func (ReviewIssueSeverity) Values() []ReviewIssueSeverity {
	return []ReviewIssueSeverity{
		ReviewIssueSeverityInfo,
		ReviewIssueSeverityLow,
		ReviewIssueSeverityMedium,
		ReviewIssueSeverityHigh,
		ReviewIssueSeverityCritical,
	}
}

// IsValid checks whether the given ReviewIssueSeverity value is valid.
func (e ReviewIssueSeverity) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ReviewIssueSeverity.
func (e ReviewIssueSeverity) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ReviewIssueSeverity: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ReviewIssueSeverity.
func (e *ReviewIssueSeverity) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ReviewIssueSeverity(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ReviewIssueSeverity: %q", s)
	}
	return nil
}

func (e *ReviewIssueSeverity) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ReviewIssueSeverity" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ReviewIssueSeverity, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ReviewIssueSeverity(value)
}

func (e ReviewIssueSeverity) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ReviewIssueSeverity", string(e), false)
}

func (e ReviewIssueSeverity) BamlTypeName() string {
	return "ReviewIssueSeverity"
}

type ReviewIssueType string

const (
	ReviewIssueTypeBug             ReviewIssueType = "Bug"
	ReviewIssueTypeSecurity        ReviewIssueType = "Security"
	ReviewIssueTypePerformance     ReviewIssueType = "Performance"
	ReviewIssueTypeMaintainability ReviewIssueType = "Maintainability"
	ReviewIssueTypeStyle           ReviewIssueType = "Style"
	ReviewIssueTypeDocumentation   ReviewIssueType = "Documentation"
	ReviewIssueTypeComplexity      ReviewIssueType = "Complexity"
	ReviewIssueTypeDeadCode        ReviewIssueType = "DeadCode"
	ReviewIssueTypeDuplication     ReviewIssueType = "Duplication"
)

// Values returns all allowed values for the ReviewIssueType type.
func (ReviewIssueType) Values() []ReviewIssueType {
	return []ReviewIssueType{
		ReviewIssueTypeBug,
		ReviewIssueTypeSecurity,
		ReviewIssueTypePerformance,
		ReviewIssueTypeMaintainability,
		ReviewIssueTypeStyle,
		ReviewIssueTypeDocumentation,
		ReviewIssueTypeComplexity,
		ReviewIssueTypeDeadCode,
		ReviewIssueTypeDuplication,
	}
}

// IsValid checks whether the given ReviewIssueType value is valid.
func (e ReviewIssueType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ReviewIssueType.
func (e ReviewIssueType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ReviewIssueType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ReviewIssueType.
func (e *ReviewIssueType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ReviewIssueType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ReviewIssueType: %q", s)
	}
	return nil
}

func (e *ReviewIssueType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ReviewIssueType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ReviewIssueType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ReviewIssueType(value)
}

func (e ReviewIssueType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ReviewIssueType", string(e), false)
}

func (e ReviewIssueType) BamlTypeName() string {
	return "ReviewIssueType"
}

type ReviewRecommendation string

const (
	ReviewRecommendationApprove        ReviewRecommendation = "Approve"
	ReviewRecommendationApproveMinor   ReviewRecommendation = "ApproveMinor"
	ReviewRecommendationRequestChanges ReviewRecommendation = "RequestChanges"
	ReviewRecommendationReject         ReviewRecommendation = "Reject"
)

// Values returns all allowed values for the ReviewRecommendation type.
func (ReviewRecommendation) Values() []ReviewRecommendation {
	return []ReviewRecommendation{
		ReviewRecommendationApprove,
		ReviewRecommendationApproveMinor,
		ReviewRecommendationRequestChanges,
		ReviewRecommendationReject,
	}
}

// IsValid checks whether the given ReviewRecommendation value is valid.
func (e ReviewRecommendation) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ReviewRecommendation.
func (e ReviewRecommendation) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ReviewRecommendation: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ReviewRecommendation.
func (e *ReviewRecommendation) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ReviewRecommendation(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ReviewRecommendation: %q", s)
	}
	return nil
}

func (e *ReviewRecommendation) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ReviewRecommendation" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ReviewRecommendation, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ReviewRecommendation(value)
}

func (e ReviewRecommendation) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ReviewRecommendation", string(e), false)
}

func (e ReviewRecommendation) BamlTypeName() string {
	return "ReviewRecommendation"
}

type RiskLevel string

const (
	RiskLevelLow      RiskLevel = "Low"
	RiskLevelMedium   RiskLevel = "Medium"
	RiskLevelHigh     RiskLevel = "High"
	RiskLevelCritical RiskLevel = "Critical"
)

// Values returns all allowed values for the RiskLevel type.
func (RiskLevel) Values() []RiskLevel {
	return []RiskLevel{
		RiskLevelLow,
		RiskLevelMedium,
		RiskLevelHigh,
		RiskLevelCritical,
	}
}

// IsValid checks whether the given RiskLevel value is valid.
func (e RiskLevel) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for RiskLevel.
func (e RiskLevel) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid RiskLevel: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for RiskLevel.
func (e *RiskLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = RiskLevel(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid RiskLevel: %q", s)
	}
	return nil
}

func (e *RiskLevel) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "RiskLevel" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.RiskLevel, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = RiskLevel(value)
}

func (e RiskLevel) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("RiskLevel", string(e), false)
}

func (e RiskLevel) BamlTypeName() string {
	return "RiskLevel"
}

type TestType string

const (
	TestTypeUnit        TestType = "Unit"
	TestTypeIntegration TestType = "Integration"
	TestTypeE2E         TestType = "E2E"
	TestTypeSnapshot    TestType = "Snapshot"
	TestTypeProperty    TestType = "Property"
)

// Values returns all allowed values for the TestType type.
func (TestType) Values() []TestType {
	return []TestType{
		TestTypeUnit,
		TestTypeIntegration,
		TestTypeE2E,
		TestTypeSnapshot,
		TestTypeProperty,
	}
}

// IsValid checks whether the given TestType value is valid.
func (e TestType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for TestType.
func (e TestType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid TestType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for TestType.
func (e *TestType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = TestType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid TestType: %q", s)
	}
	return nil
}

func (e *TestType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "TestType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.TestType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = TestType(value)
}

func (e TestType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("TestType", string(e), false)
}

func (e TestType) BamlTypeName() string {
	return "TestType"
}

type VerificationMethod string

const (
	VerificationMethodSyntaxCheck VerificationMethod = "SyntaxCheck"
	VerificationMethodBuild       VerificationMethod = "Build"
	VerificationMethodTest        VerificationMethod = "Test"
	VerificationMethodLint        VerificationMethod = "Lint"
	VerificationMethodManual      VerificationMethod = "Manual"
)

// Values returns all allowed values for the VerificationMethod type.
func (VerificationMethod) Values() []VerificationMethod {
	return []VerificationMethod{
		VerificationMethodSyntaxCheck,
		VerificationMethodBuild,
		VerificationMethodTest,
		VerificationMethodLint,
		VerificationMethodManual,
	}
}

// IsValid checks whether the given VerificationMethod value is valid.
func (e VerificationMethod) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for VerificationMethod.
func (e VerificationMethod) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid VerificationMethod: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for VerificationMethod.
func (e *VerificationMethod) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = VerificationMethod(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid VerificationMethod: %q", s)
	}
	return nil
}

func (e *VerificationMethod) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "VerificationMethod" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.VerificationMethod, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = VerificationMethod(value)
}

func (e VerificationMethod) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("VerificationMethod", string(e), false)
}

func (e VerificationMethod) BamlTypeName() string {
	return "VerificationMethod"
}
