package queue

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	appconfig "github.com/antinvestor/builder/apps/worker/config"
	"github.com/antinvestor/builder/apps/worker/service/repository"
	"github.com/antinvestor/builder/internal/events"
)

// EventsEmitter emits events.
type EventsEmitter interface {
	Emit(ctx context.Context, eventName string, payload any) error
}

// FeatureRequestHandler handles incoming feature requests from the gateway.
type FeatureRequestHandler struct {
	cfg           *appconfig.WorkerConfig
	executionRepo repository.ExecutionRepository
	eventsMan     EventsEmitter
}

// NewFeatureRequestHandler creates a new feature request handler.
func NewFeatureRequestHandler(
	cfg *appconfig.WorkerConfig,
	executionRepo repository.ExecutionRepository,
	eventsMan EventsEmitter,
) *FeatureRequestHandler {
	return &FeatureRequestHandler{
		cfg:           cfg,
		executionRepo: executionRepo,
		eventsMan:     eventsMan,
	}
}

// FeatureRequest is the incoming feature request from the gateway.
type FeatureRequest struct {
	// ExecutionID is the execution identifier (generated by gateway or provided).
	ExecutionID string `json:"execution_id,omitempty"`

	// RepositoryURL is the git repository URL.
	RepositoryURL string `json:"repository_url"`

	// Branch is the target branch.
	Branch string `json:"branch"`

	// Specification is the feature specification.
	Specification FeatureSpecification `json:"specification"`

	// RequestedBy identifies who requested the feature.
	RequestedBy string `json:"requested_by,omitempty"`

	// RequestedAt is when the request was made.
	RequestedAt time.Time `json:"requested_at,omitempty"`
}

// FeatureSpecification describes the feature to build.
type FeatureSpecification struct {
	Title        string   `json:"title"`
	Description  string   `json:"description"`
	Requirements []string `json:"requirements,omitempty"`
	TargetFiles  []string `json:"target_files,omitempty"`
	Language     string   `json:"language,omitempty"`
}

// Handle processes incoming feature request messages.
func (h *FeatureRequestHandler) Handle(
	ctx context.Context,
	headers map[string]string,
	payload []byte,
) error {
	var request FeatureRequest
	if err := json.Unmarshal(payload, &request); err != nil {
		return fmt.Errorf("unmarshal feature request: %w", err)
	}

	// Generate execution ID if not provided
	var execID events.ExecutionID
	if request.ExecutionID != "" {
		var err error
		execID, err = events.ParseExecutionID(request.ExecutionID)
		if err != nil {
			execID = events.NewExecutionID()
		}
	} else {
		execID = events.NewExecutionID()
	}

	// Set request time if not provided
	if request.RequestedAt.IsZero() {
		request.RequestedAt = time.Now()
	}

	// Create execution record
	execution := &repository.Execution{
		ID:            execID.String(),
		RepositoryURL: request.RepositoryURL,
		Branch:        request.Branch,
		Title:         request.Specification.Title,
		Description:   request.Specification.Description,
		Status:        repository.ExecutionStatusPending,
		RequestedBy:   request.RequestedBy,
		RequestedAt:   request.RequestedAt,
		CreatedAt:     time.Now(),
	}

	if err := h.executionRepo.Create(ctx, execution); err != nil {
		return fmt.Errorf("create execution record: %w", err)
	}

	// Emit initialization event
	initPayload := &events.FeatureExecutionInitializedPayload{
		Spec: events.FeatureSpecification{
			Title:              request.Specification.Title,
			Description:        request.Specification.Description,
			AcceptanceCriteria: request.Specification.Requirements,
			PathHints:          request.Specification.TargetFiles,
		},
		Repository: events.RepositoryContext{
			RemoteURL:    request.RepositoryURL,
			TargetBranch: request.Branch,
		},
		Constraints: events.ExecutionConstraints{
			MaxSteps:       h.cfg.MaxStepsPerExecution,
			TimeoutSeconds: h.cfg.ExecutionTimeoutHours * 3600,
		},
		Request: events.RequestMetadata{
			RequestedBy:   request.RequestedBy,
			RequestedAt:   request.RequestedAt,
			RequestSource: "api",
		},
	}

	if err := h.eventsMan.Emit(ctx, string(events.FeatureExecutionInitialized), initPayload); err != nil {
		return fmt.Errorf("emit initialization event: %w", err)
	}

	return nil
}
